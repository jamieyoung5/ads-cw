\documentclass{article}
\usepackage[
backend=biber,
style=apa,
sorting=ynt
]{biblatex}


\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }

\usepackage{todonotes}
\usepackage{optidef}
\addbibresource{sample.bib}


\title{Algorithms and Data Structures Sudoku Game }
\author{Jamie Young (40544666)}
\date{}

\begin{document}
\maketitle

\section{Introduction}
According to \parencite{sudoku2024beginners}, Sudoku is a game played on a board that is generally comprised of a 9x9 grid of cells, that are categorised into a 3x3 grid of groups of these cells. Some cells will be filled in already when the game begins and the objective is to fill in every empty cell with a number ranging from 1 to 9, without repeating that number in a row, column or "category" in the grid. \\\\
With the game board, containing some starting numbers (givens), the player should be able to edit each cell except from the given numbers. An algorithm will run on-the-fly checks to tell if the board has been solved or if it is in an invalid state (e.g duplicated numbers).
Aside from the basic game, there will be additional features such as; a history of the boards state which is both viewable and stored persistently. Using the history, previous games should be able to be played through again automatically, and additional actions such as undo and redo of moves should be allowed during games. Additional game-modes will be available too, such as "time trials" (playing against a timer) and a two player mode in which you compete against a local opponent, with the winner being whoever completes their board first. Additionally, there should be size options outside the traditional 9x9 cell board, like 12x12 or 6x6 etc. Boards should also be loadable locally from a file so that people can create their own boards and share them with others.\\\\
There are many different algorithms which can be applied to solve Sudoku boards, Like 'backtracking'. Backtracking on its own can be slow for difficult puzzles however it can guarantee a solution if one exists. It is essentially a brute-force algorithm that tries to fill the Sudoku grid by placing numbers in empty cells one by one, moving forward when its placement is valid and backtracking when no valid number can be placed in the next cell. It will continue like this until a solution is found. Algorithm X is a application of backtracking targeted at Exact cover problems. Algorithm X is a recursive, nondeterministic, depth-first backtracking algorithm. It has a matrix of possibilities where the goal is to select a subset of rows where every column contains one 1. This is further improved with 'Dancing links' where a doubly linked list data structure is used to add and remove items from the matrix efficiently  \parencite{knuth2000}.
An alternative to a backtracking-based algorithm is constraint propagation which applies process of elimination to eliminate values from peers of each cell and fills a cell with a placement if its is the only possible place for a number in a row, column or sub-grid  \parencite{simonis2005}. However, constraint propagation can still be insufficient for larger or more complex puzzles, since it relies on finding direct contradictions to progress.\\\\
This document will outline and review the proposed design for a sudoku game, going over the different features to be included as well as the algorithms and data structures that will implement the application. This document will then also attempt to justify the use of these algorithms and data structures and compare them to alternatives.

\section{Design}
\subsection{Game-play}
The game will function in 2 layers of game-play loops; The top level loop will be a menu of sorts where the player can select their desired game-mode and then select options for their game (like board size, etc). The underlying loop will be the actual game-play itself, where the player(s) can commit actions, and then view the results of their actions. The player(s) can exit the game at revert back to the top level loop at any time. \\\\
The menu in the top level loop can be stored as 2d array where each index contains the game-modes/menu-items' name and a lambda function that can be injected into the main game-play loop to execute that functionality. This is a practical approach because game-modes are immutable, so there will always be a fixed amount. Each menu item will have a number associated with it (the index of its position in the array), so there is no a real need for a more complex data structure like a map or a list. Maps are an unordered data structure which makes them unsuitable for storing a menu. Arrays are also more efficient than lists; accessing an array or a list in terms of memory usage and access time. Accessing an element is always a constant time operation (O(1)), as supported by \parencite{cormen2009} in their analysis of data structures. Also, The size of an array is predetermined when memory is being allocated for it whereas a list can grow so more memory will be allocated than is actually needed, unlike an array. This can lead to inefficiency, as highlighted by \parencite{sedgewick2011} during their discussion on the trad-offs between arrays and linked lists.

\subsection{Board}
Since the board is really just a grid of cells, the board will be stored as a 2d array of records since going into any game, we will know the size of the board already and this size will be immutable once the game has started. the reason for using a record is that as well as storing each cells value, it will be useful to know each cells 'category'/'sub-grid' location later on.
Also, for the same efficiency reasons as the menu, an array is a more efficient data structure in this case over something like a list because since the size of the board wont change when we enter a game, a list which can technically be any size will typically allocate more memory than is needed \parencite{sedgewick2011}.

\subsection{Solving the board}
The algorithm I have selected for checking if a board has been successfully solved is Dancing Links. Dancing links is a highly efficient algorithm when solving sudoku puzzles and it also scales well (although its performance does degrade with larger board sizes), as it is quite efficient at pruning the algorithms search space \parencite{knuth2000}. This is important in my case, where my game will have varying board sizes and on-the-fly checks for a complete board. Dancing links is a more efficient implementation of 'Algorithm X', which is a general backtracking algorithm aimed at solving exact cover problems (which includes Sudoku boards) \parencite{knuth2000}. Dancing links is more efficient because it uses doubly linked lists to add and remove nodes from algorithm X's consideration set which makes the backtracking process more efficient. The exact time complexity of this algorithms is difficult to define without knowing the actual dataset, generally though it is agreed that the worst case scenario is an exponential complexity, mostly because of the varying number of permutations it has to explore which is influenced by the boards initial values and size \parencite{sedgewick2011}.\\\\
More specifically on how Algorithm X works (and how a dancing links implementation affects it); There is a matrix (consisting of 0's and 1's) where the rows contain each possible appearance of a number in the board and the columns correspond to the constraints imposed by the game (no repeating numbers in rows, columns or sub-grids). The algorithm iterates through these possible appearances and covers and uncovers them to explore different solution paths \parencite{knuth2000}. When a row gets selected all other possible appearances that conflict with the placement are temporarily removed from consideration (covering). If a dead-end gets reached, where there is not any possible solution the algorithm backtracks (uncovering) through the possible appearances to explore other paths. This entire process gets repeated recursively through the reduced matrix and once no rows are left a solution is found. Dancing links is pretty much just an enhancement to this, where rows and columns are represented with doubly linked lists. Each node in the list represents a 1 in the matrix and horizontally and vertically links to its adjacent nodes horizontally and vertically. We then get a circular list where each node now knows its neighbours which makes removals and insertions quick \parencite{knuth2000}.

\subsection{Game History}
Our game history is essentially going to be a history of the boards state throughout a game of Sudoku. The history should in turn also allow undo/redo's of actions modifying the boards state as well as allow the automatic replaying of previous games' histories. \\\\
There are several different data structures that could represent the game history; doubly linked lists where each node represents the boards state and links both to the next board state and last board state, a stack where each item in the stack is the boards state, or simply a list where each index is the boards state. \\\\
A doubly linked list would be useful since we require bi-directional movement through the history to undo and redo and unlike a simple list there is no reallocation or copying of the entire data structure required when the history grows or shrinks \parencite{cormen2009}. However, since we need pointers for the future and past states there is additional memory overhead. On the contrary, there's no pointers to neighbours in our simple list so it can be more memory efficient. It is a nice and simple data model however resizing can be costly memory-wise. \\\\
A stack however, is perfectly suited to our problem. It perfectly matches the redo/undo case and this means we can avoid more complex logic needed if we were using just a list. It's 2 operations, pop and push operating in a constant time complexity. However when replaying games we would need to reverse the stack if we want to replay the game from the start. \\\\
This is why, I propose representing the history as a stack during the game, and then store it as a list when we persist the history data. This also means that when we do game replays the history will be represented as a list which means we don't need to do operations like reversing our stack. Also though it should be noted that, since we are using a stack to represent in-game history, we will actually need two stacks since when we pop (undo) a state we need to be able to push (redo) the last popped state back into our history stack. So any state popped from history will be pushed onto a secondary stack for this purpose.

\subsection{Two player mode}
Implementing two player mode so that the players are competing in real time, in the console, using polling or something will be too complex for this project. The players will compete in a turn based 'battle'. Each turn, the player will have a variable amount of time (select-able in the main game-play loop) to choose a valid placement. If they submit a placement before the time runs out, whether valid or invalid the turn will roll to their opponent. This will go on forever until a player forfeits or someone gets a valid board. \\\\
Due to its first in, first out nature, a queue is ideal for managing our players turns, as discussed by \parencite{goodrich2013} queues are a highly efficient solution for scenarios requiring the orderly processing of elements, which aligns with the sequential nature of rotating player turns. When the game starts, objects representing players will are enqueued, and when their turn concludes the player will be dequeued and enqueued at the back if the game has not met a end condition. The object that represents the player will include a guid as a unique identifier of the player, an identifier for their action (placement, undo, redo), whether the action was valid and the duration of the turn. Each player will be stored in a map, with the key being their guid and the value being an object containing data like their game history, name, and whether or not they are still playing. Representing data in this way and storing things like if they are still playing, means that in the future this can be expanded to games with more than 2 people.

\subsection{Time trial}
The time trial mode will essentially consist of a timer running alongside your game. The difficulty (equating to the time your given) can be selected from the main game-play loop. If the timer runs out before you have completed the board you have failed, and if you complete it within the time you succeed. A timestamp will also be taken at the game start and a timestamp taken at game end to be stored alongside the games history. The timer itself can be just a primitive data type like an int, that in a separate thread can be subtracted from each second in a loop. Doing this in a separate thread allows the timer to run in tandem with the actual game. The loop will be conditional and once the timer reaches 0 it will send out a call to the main thread to stop the game.

\medskip

\printbibliography
\end{document}